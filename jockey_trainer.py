# -*- coding: utf-8 -*-
"""
Reads the full parsed Brisnet data CSV and selects a specific subset
of columns, saving the result to a new CSV file.
"""
from __future__ import annotations

import pandas as pd
from pathlib import Path
from typing import List, Final

# --- Configuration ---

# 1. Define paths relative to the script location
SCRIPT_DIR: Final[Path] = Path(__file__).parent.resolve()

# 2. Input file (the output from the previous parsing script)
INPUT_CSV_FILENAME: Final[str] = "parsed_race_data.csv"
INPUT_CSV_FILE_PATH: Final[Path] = SCRIPT_DIR / INPUT_CSV_FILENAME

# 3. Output file name for the selected data
OUTPUT_SELECTED_CSV_FILENAME: Final[str] = "selected_race_info.csv"
OUTPUT_SELECTED_CSV_FILE_PATH: Final[Path] = SCRIPT_DIR / OUTPUT_SELECTED_CSV_FILENAME

# 4. Define the EXACT column names to select
#    These should match the unique labels generated by bris_spec.py
#    Verify these names against the header row of parsed_race_data.csv if unsure.
COLUMNS_TO_SELECT: Final[List[str]] = [
    'race',                         # Field 3
    'post_times_by_region',         # Field 1374
    'post_position',                # Field 4
    'horse_name',                   # Field 45
    'today_s_trainer',              # Field 28
    'today_s_jockey',               # Field 33
    't_j_combo_starts_meet',        # Field 1413
    't_j_combo_wins_meet',          # Field 1414
    't_j_combo_places_meet',        # Field 1415
    't_j_combo_shows_meet',         # Field 1416
    't_j_combo_2_roi_meet',         # Field 1417
]

# --- End Configuration ---


# --- Main Execution ---
if __name__ == "__main__":
    # 1. Check if the input file exists
    if not INPUT_CSV_FILE_PATH.exists():
        print(f"Error: Input file not found at {INPUT_CSV_FILE_PATH}")
        print("Please ensure 'parsed_race_data.csv' exists in the script directory.")
        # Exit if the input file isn't there
        exit()

    print(f"Reading full data from: {INPUT_CSV_FILE_PATH}")
    try:
        # 2. Read the full CSV data
        full_df = pd.read_csv(
            INPUT_CSV_FILE_PATH,
            low_memory=False, # Good practice for potentially large files
            encoding='utf-8'  # Match encoding used during saving
        )
        print(f"Successfully read {len(full_df)} lines.")

        # 3. Check if required columns exist
        missing_cols = [col for col in COLUMNS_TO_SELECT if col not in full_df.columns]
        if missing_cols:
            print("\nWarning: The following requested columns were not found in the input CSV:")
            for col in missing_cols:
                print(f"- {col}")
            # Filter the list to only include columns that actually exist
            columns_that_exist = [col for col in COLUMNS_TO_SELECT if col in full_df.columns]
            if not columns_that_exist:
                print("Error: None of the requested columns were found. Cannot create output file.")
                exit() # Exit if none of the desired columns are present
            print("Proceeding with the columns that were found.")
        else:
            columns_that_exist = COLUMNS_TO_SELECT # All columns were found


        # 4. Select the desired columns
        print(f"\nSelecting columns: {', '.join(columns_that_exist)}")
        selected_df = full_df[columns_that_exist].copy() # Use .copy() to avoid SettingWithCopyWarning

        # 5. Save the selected data to a new CSV
        try:
            selected_df.to_csv(OUTPUT_SELECTED_CSV_FILE_PATH, index=False, encoding='utf-8')
            print(f"\nSuccessfully saved selected data to: {OUTPUT_SELECTED_CSV_FILE_PATH}")
            print(f"Selected DataFrame shape: {selected_df.shape}") # Show rows/cols selected

        except Exception as e:
            print(f"\nError saving selected data to CSV file {OUTPUT_SELECTED_CSV_FILE_PATH}: {e}")

    except FileNotFoundError:
         # This case should be caught by the initial check, but good to have
         print(f"Error: Input file not found at {INPUT_CSV_FILE_PATH}")
    except Exception as e:
        print(f"\nAn unexpected error occurred while reading or processing the file: {e}")

