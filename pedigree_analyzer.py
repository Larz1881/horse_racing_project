# -*- coding: utf-8 -*-
"""
Analyzes parsed Brisnet race data to display specific pedigree and auction
information for each race, using known column names, removing BRIS ratings,
and applying custom column order and renaming for display.
"""
from __future__ import annotations

import pandas as pd
from pathlib import Path
from typing import List, Final, Optional, Dict

# --- Configuration ---

# 1. Define paths relative to the script location
SCRIPT_DIR: Final[Path] = Path(__file__).parent.resolve()

# 2. Input file (ensure this is generated by bris_spec.py or similar)
PARSED_DATA_FILENAME: Final[str] = "parsed_race_data_nonempty.csv"
PARSED_DATA_FILE_PATH: Final[Path] = SCRIPT_DIR / PARSED_DATA_FILENAME

# 3. Define the EXACT original column names needed from the CSV file
#    (Excludes BRIS ratings, includes 'race' for grouping)
ORIGINAL_COLUMNS_TO_LOAD: Final[List[str]] = [
    'race', # Essential for grouping, will be excluded from display
    'program_number_if_available',
    'horse_name',
    'morn_line_odds_if_available',
    'auction_price',
    'where_when_sold_at_auction',
    'sire',
    'sire_stud_fee_current',
    'sire_s_sire',
    'dam',
    'dam_s_sire',
    'breeder',
    'state_country_abrv_where_bred'
]

# 4. Define the desired ORDER of columns for the final DISPLAY
#    (Using the original names, excluding 'race')
DISPLAY_ORDER_ORIGINAL_NAMES: Final[List[str]] = [
    'program_number_if_available',
    'horse_name',
    'morn_line_odds_if_available',
    'auction_price',
    'where_when_sold_at_auction',
    'breeder',
    'state_country_abrv_where_bred',
    'sire_stud_fee_current',
    'sire',
    'sire_s_sire',
    'dam',
    'dam_s_sire',
]

# 5. Define the mapping from original column names to desired display names
#    (Only include mappings for columns in DISPLAY_ORDER_ORIGINAL_NAMES)
COLUMN_RENAME_MAP: Final[Dict[str, str]] = {
    'program_number_if_available': 'Number',
    'horse_name': 'Name',
    'morn_line_odds_if_available': 'M/L Odds',
    'auction_price': 'Auction Price',
    'where_when_sold_at_auction': 'Auction',
    'breeder': 'Breeder',
    'state_country_abrv_where_bred': 'Location',
    'sire_stud_fee_current': 'Stud Fee',
    'sire': 'Sire',
    'sire_s_sire': 'Grandsire',
    'dam': 'Dam',
    'dam_s_sire': 'Dam Sire',
    # 'race' mapping is not needed here as it's not displayed in the table
}

# --- End Configuration ---


def load_parsed_data(data_path: Path, required_columns: List[str]) -> Optional[pd.DataFrame]:
    """Loads the parsed race data CSV file, selecting only required columns."""
    if not data_path.exists():
        print(f"\nError: Parsed data file not found at {data_path}")
        print(f"Please ensure '{PARSED_DATA_FILENAME}' exists in the script directory.")
        return None

    print(f"\nLoading parsed race data from: {data_path}")
    # Filter required_columns to only those actually expected based on the latest list
    columns_to_attempt = list(set(required_columns)) # Use set to avoid duplicates if any
    print(f"Attempting to load columns: {', '.join(columns_to_attempt)}")

    try:
        df = pd.read_csv(data_path, usecols=columns_to_attempt, low_memory=False, encoding='utf-8')
        print(f"Successfully loaded data with {df.shape[0]} rows and {df.shape[1]} columns.")
        missing_cols = [col for col in columns_to_attempt if col not in df.columns]
        if missing_cols:
             print(f"\nWarning: The following required columns were not found in the CSV file:")
             for col in missing_cols:
                 print(f"- {col}")
        return df
    except ValueError as e:
         print(f"\nError loading CSV: {e}")
         print("This likely means one or more of the required columns are missing from the file.")
         print(f"Please check the header row in '{data_path.name}'.")
         return None
    except Exception as e:
        print(f"\nAn unexpected error occurred while loading the parsed data: {e}")
        return None

# --- Main Execution ---
if __name__ == "__main__":
    # 1. Make sure 'race' column is included for loading/grouping
    RACE_COLUMN_NAME = 'race' # Assuming this is the correct name
    if RACE_COLUMN_NAME not in ORIGINAL_COLUMNS_TO_LOAD:
        print(f"Error: The essential grouping column '{RACE_COLUMN_NAME}' is not in ORIGINAL_COLUMNS_TO_LOAD.")
        print("Script needs 'race' column to function.")
        exit()

    # Check if display order contains columns not intended to be loaded
    mismatched_cols = [col for col in DISPLAY_ORDER_ORIGINAL_NAMES if col not in ORIGINAL_COLUMNS_TO_LOAD]
    if mismatched_cols:
        print("\nConfiguration Warning: The following columns are in DISPLAY_ORDER_ORIGINAL_NAMES")
        print("but not in ORIGINAL_COLUMNS_TO_LOAD and will be ignored:")
        for col in mismatched_cols:
            print(f"- {col}")

    # 2. Load the parsed data using only the necessary original column names
    race_data_df = load_parsed_data(PARSED_DATA_FILE_PATH, ORIGINAL_COLUMNS_TO_LOAD)

    if race_data_df is not None:
        # 3. Ensure race column is suitable for grouping
        try:
            race_data_df[RACE_COLUMN_NAME] = pd.to_numeric(race_data_df[RACE_COLUMN_NAME], errors='coerce')
            race_data_df.dropna(subset=[RACE_COLUMN_NAME], inplace=True)
            if race_data_df.empty:
                 print("\nError: No valid race numbers found after cleaning. Cannot group.")
                 exit()
            race_data_df[RACE_COLUMN_NAME] = race_data_df[RACE_COLUMN_NAME].astype(int)
        except KeyError:
             print(f"\nError: The race column '{RACE_COLUMN_NAME}' was not found in the loaded data.")
             print("Cannot group by race.")
             exit()
        except Exception as e:
            print(f"\nError processing the race column ('{RACE_COLUMN_NAME}'): {e}")
            exit()

        # 4. Group data by race and display the table with specified columns, order, and names
        print(f"\n--- Pedigree and Auction Information by Race ---")

        # Get the list of original columns that were actually loaded AND are in the desired display order
        available_display_columns_original = [
            col for col in DISPLAY_ORDER_ORIGINAL_NAMES if col in race_data_df.columns
        ]

        if not available_display_columns_original:
            print("\nError: None of the desired display columns were found in the loaded data. Cannot proceed.")
            exit()

        # Filter the rename map to only include available display columns
        active_rename_map = {orig_name: new_name
                             for orig_name, new_name in COLUMN_RENAME_MAP.items()
                             if orig_name in available_display_columns_original}

        grouped_by_race = race_data_df.groupby(RACE_COLUMN_NAME)

        for race_num, race_group_df in grouped_by_race:
            print(f"\n=== Race {race_num} ===")

            if race_group_df.empty:
                 print("  No data available for this race with the selected columns.")
                 continue

            # Select only the available display columns in the desired order
            display_df = race_group_df[available_display_columns_original].copy() # Use .copy()

            # Rename the columns for display
            display_df.rename(columns=active_rename_map, inplace=True)

            if not display_df.empty:
                # Display the table for the race
                pd.set_option('display.max_columns', None)
                pd.set_option('display.width', 1000)
                print(display_df.to_string(index=False))

        print("\n--- Analysis Complete ---")

    else:
        print("\nCould not load parsed data. Aborting.")