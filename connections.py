# -*- coding: utf-8 -*-
"""
Analyzes parsed Brisnet race data to display connections (Trainer, Jockey,
Owner, Breeder) and related information (Auction, Stud Fee) for each race.
"""
from __future__ import annotations

import pandas as pd
from pathlib import Path
from typing import List, Final, Optional, Dict

# --- Configuration ---

# 1. Define paths relative to the script location
SCRIPT_DIR: Final[Path] = Path(__file__).parent.resolve()

# 2. Input file (ensure this is generated by bris_spec.py or similar)
PARSED_DATA_FILENAME: Final[str] = "parsed_race_data_nonempty.csv"
PARSED_DATA_FILE_PATH: Final[Path] = SCRIPT_DIR / PARSED_DATA_FILENAME

# 3. Define the EXACT original column names needed from the CSV file
#    Includes 'race' for grouping. Verify these names match your CSV headers.
ORIGINAL_COLUMNS_TO_LOAD: Final[List[str]] = [
    'race', # Essential for grouping
    'program_number_if_available',
    'horse_name',
    'morn_line_odds_if_available',
    'today_s_trainer',
    'today_s_jockey',
    'today_s_owner',
    'auction_price',
    'where_when_sold_at_auction',
    'breeder',
    'state_country_abrv_where_bred',
    'sire_stud_fee_current'
]

# 4. Define the desired ORDER of columns for the final DISPLAY
#    (Using the original names, excluding 'race')
DISPLAY_ORDER_ORIGINAL_NAMES: Final[List[str]] = [
    'program_number_if_available',
    'horse_name',
    'morn_line_odds_if_available',
    'today_s_trainer',
    'today_s_jockey',
    'today_s_owner',
    'auction_price',
    'where_when_sold_at_auction',
    'breeder',
    'state_country_abrv_where_bred',
    'sire_stud_fee_current'
]

# 5. Define the mapping from original column names to desired display names
COLUMN_RENAME_MAP: Final[Dict[str, str]] = {
    'program_number_if_available': 'Number',
    'horse_name': 'Name',
    'morn_line_odds_if_available': 'M/L Odds',
    'today_s_trainer': 'Trainer',
    'today_s_jockey': 'Jockey',
    'today_s_owner': 'Owner',
    'auction_price': 'Auction Price',
    'where_when_sold_at_auction': 'Auction',
    'breeder': 'Breeder',
    'state_country_abrv_where_bred': 'Location',
    'sire_stud_fee_current': 'Stud Fee',
    # 'race' mapping is not needed here as it's not displayed in the table
}

# --- End Configuration ---


def load_parsed_data(data_path: Path, required_columns: List[str]) -> Optional[pd.DataFrame]:
    """Loads the parsed race data CSV file, selecting only specified columns."""
    if not data_path.exists():
        print(f"\nError: Parsed data file not found at {data_path}")
        print(f"Please ensure '{PARSED_DATA_FILENAME}' exists in the script directory.")
        return None

    print(f"\nLoading parsed race data from: {data_path}")
    # Use a copy to avoid modifying the constant list
    columns_to_attempt = list(required_columns)
    print(f"Attempting to load columns: {', '.join(columns_to_attempt)}")

    try:
        df = pd.read_csv(data_path, usecols=columns_to_attempt, low_memory=False, encoding='utf-8')
        print(f"Successfully loaded data with {df.shape[0]} rows and {df.shape[1]} columns.")
        # Verify columns were loaded - read_csv with usecols raises error if col missing,
        # but this check is good practice if loading logic changes.
        missing_cols = [col for col in columns_to_attempt if col not in df.columns]
        if missing_cols:
             print(f"\nWarning: The following required columns were not found in the loaded data:")
             for col in missing_cols:
                 print(f"- {col}")
             # Depending on severity, you might want to exit() here
        return df
    except ValueError as e:
         print(f"\nError loading CSV: {e}")
         print("This likely means one or more specified columns are missing from the file.")
         print(f"Please check the header row in '{data_path.name}' and the ORIGINAL_COLUMNS_TO_LOAD list.")
         return None
    except FileNotFoundError: # Explicitly catch FileNotFoundError
        print(f"\nError: Input file not found at {data_path}")
        return None
    except Exception as e:
        print(f"\nAn unexpected error occurred while loading the parsed data: {e}")
        return None

# --- Main Execution ---
if __name__ == "__main__":
    # 1. Make sure 'race' column is included for loading/grouping
    RACE_COLUMN_NAME = 'race' # Assuming this is the correct name
    if RACE_COLUMN_NAME not in ORIGINAL_COLUMNS_TO_LOAD:
        print(f"Configuration Error: The essential grouping column '{RACE_COLUMN_NAME}' is not in ORIGINAL_COLUMNS_TO_LOAD.")
        print("Script needs 'race' column to function.")
        exit()

    # Optional: Check if display order or rename map contains columns not intended to be loaded
    mismatched_display = [col for col in DISPLAY_ORDER_ORIGINAL_NAMES if col not in ORIGINAL_COLUMNS_TO_LOAD]
    if mismatched_display:
        print("\nConfiguration Warning: The following columns are in DISPLAY_ORDER_ORIGINAL_NAMES")
        print("but not in ORIGINAL_COLUMNS_TO_LOAD and will be ignored:")
        for col in mismatched_display: print(f"- {col}")

    mismatched_rename = [col for col in COLUMN_RENAME_MAP if col not in ORIGINAL_COLUMNS_TO_LOAD]
    if mismatched_rename:
        print("\nConfiguration Warning: The following columns are in COLUMN_RENAME_MAP")
        print("but not in ORIGINAL_COLUMNS_TO_LOAD and their mappings will be ignored:")
        for col in mismatched_rename: print(f"- {col}")


    # 2. Load the parsed data using only the necessary original column names
    race_data_df = load_parsed_data(PARSED_DATA_FILE_PATH, ORIGINAL_COLUMNS_TO_LOAD)

    if race_data_df is not None:
        # 3. Ensure race column is suitable for grouping
        try:
            # Ensure race column exists before attempting conversion
            if RACE_COLUMN_NAME not in race_data_df.columns:
                 raise KeyError(f"The race column '{RACE_COLUMN_NAME}' was not found after loading data.")
            race_data_df[RACE_COLUMN_NAME] = pd.to_numeric(race_data_df[RACE_COLUMN_NAME], errors='coerce')
            race_data_df.dropna(subset=[RACE_COLUMN_NAME], inplace=True)
            if race_data_df.empty:
                 print("\nError: No valid race numbers found after cleaning. Cannot group.")
                 exit()
            race_data_df[RACE_COLUMN_NAME] = race_data_df[RACE_COLUMN_NAME].astype(int)
        except KeyError as e:
             print(f"\nError: {e}")
             print("Cannot group by race.")
             exit()
        except Exception as e:
            print(f"\nError processing the race column ('{RACE_COLUMN_NAME}'): {e}")
            exit()

        # 4. Group data by race and display the table with specified columns, order, and names
        print(f"\n--- Connections Information by Race ({pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}) ---")

        # Get the list of original columns that were actually loaded AND are in the desired display order
        available_display_columns_original = [
            col for col in DISPLAY_ORDER_ORIGINAL_NAMES if col in race_data_df.columns
        ]

        if not available_display_columns_original:
            print("\nError: None of the desired display columns were found in the loaded data. Cannot proceed.")
            exit()

        # Filter the rename map to only include available display columns
        active_rename_map = {orig_name: new_name
                             for orig_name, new_name in COLUMN_RENAME_MAP.items()
                             if orig_name in available_display_columns_original}

        grouped_by_race = race_data_df.groupby(RACE_COLUMN_NAME)

        for race_num, race_group_df in grouped_by_race:
            print(f"\n=== Race {race_num} ===")

            if race_group_df.empty:
                 print("  No data available for this race with the selected columns.")
                 continue

            # Select only the available display columns in the desired order
            # Use .copy() to ensure we are working with a separate DataFrame slice
            display_df = race_group_df[available_display_columns_original].copy()

            # Rename the columns for display
            display_df.rename(columns=active_rename_map, inplace=True)

            if not display_df.empty:
                # Display the table for the race
                pd.set_option('display.max_columns', None)
                pd.set_option('display.width', 1000) # Adjust width as needed
                print(display_df.to_string(index=False))

        print("\n--- Analysis Complete ---")

    else:
        print("\nCould not load parsed data. Aborting.")